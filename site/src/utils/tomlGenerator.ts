import type { NodeProfile } from '../types';

/**
 * Generates a Proxmox answer.toml file from a NodeProfile
 * Uses GitHub Secrets placeholders for sensitive data
 */
export function generateAnswerToml(profile: NodeProfile, useSecrets = true): string {
  const lines: string[] = [];

  // Header comment
  lines.push(`# Proxmox VE Automated Installation Answer File`);
  lines.push(`# Generated by Proxmox Deployer`);
  lines.push(`# Profile: ${profile.name}`);
  lines.push(`# Generated: ${new Date().toISOString()}`);
  lines.push('');

  // Global section
  lines.push('[global]');
  lines.push(`keyboard = "${profile.global.keyboard}"`);
  lines.push(`country = "${profile.global.country}"`);
  lines.push(`fqdn = "${profile.global.fqdn}"`);
  lines.push(`mailto = "${profile.global.mailto}"`);
  lines.push(`timezone = "${profile.global.timezone}"`);

  // Root password - use placeholder for GitHub Secrets
  if (useSecrets) {
    lines.push(`root-password = "\${ROOT_PASSWORD}"`);
  } else if (profile.global.rootPasswordHashed) {
    lines.push(`root-password-hashed = "${profile.global.rootPasswordHashed}"`);
  } else if (profile.global.rootPassword) {
    lines.push(`root-password = "${profile.global.rootPassword}"`);
  }

  // SSH keys - use placeholder for GitHub Secrets
  if (useSecrets) {
    lines.push(`root-ssh-keys = ["\${ROOT_SSH_KEY}"]`);
  } else if (profile.global.rootSshKeys && profile.global.rootSshKeys.length > 0) {
    const keys = profile.global.rootSshKeys.map(k => `    "${k}"`).join(',\n');
    lines.push(`root-ssh-keys = [\n${keys}\n]`);
  }

  if (profile.global.rebootOnError !== undefined) {
    lines.push(`reboot-on-error = ${profile.global.rebootOnError}`);
  }
  if (profile.global.rebootMode) {
    lines.push(`reboot-mode = "${profile.global.rebootMode}"`);
  }
  lines.push('');

  // Network section
  lines.push('[network]');
  lines.push(`source = "${profile.network.source}"`);

  if (profile.network.source === 'from-answer') {
    if (profile.network.cidr) lines.push(`cidr = "${profile.network.cidr}"`);
    if (profile.network.gateway) lines.push(`gateway = "${profile.network.gateway}"`);
    if (profile.network.dns) lines.push(`dns = "${profile.network.dns}"`);
  }

  if (profile.network.filter) {
    for (const [key, value] of Object.entries(profile.network.filter)) {
      lines.push(`filter.${key} = "${value}"`);
    }
  }
  lines.push('');

  // Disk setup section
  lines.push('[disk-setup]');
  lines.push(`filesystem = "${profile.diskSetup.filesystem}"`);

  if (profile.diskSetup.diskList && profile.diskSetup.diskList.length > 0) {
    const disks = profile.diskSetup.diskList.map(d => `"${d}"`).join(', ');
    lines.push(`disk-list = [${disks}]`);
  }

  if (profile.diskSetup.filter) {
    for (const [key, value] of Object.entries(profile.diskSetup.filter)) {
      lines.push(`filter.${key} = "${value}"`);
    }
  }

  if (profile.diskSetup.filterMatch) {
    lines.push(`filter-match = "${profile.diskSetup.filterMatch}"`);
  }
  lines.push('');

  // ZFS options
  if (profile.diskSetup.filesystem === 'zfs' && profile.diskSetup.zfs) {
    const zfs = profile.diskSetup.zfs;
    lines.push(`zfs.raid = "${zfs.raid}"`);
    if (zfs.ashift) lines.push(`zfs.ashift = ${zfs.ashift}`);
    if (zfs.compress) lines.push(`zfs.compress = "${zfs.compress}"`);
    if (zfs.checksum) lines.push(`zfs.checksum = "${zfs.checksum}"`);
    if (zfs.arcMax) lines.push(`zfs.arc-max = ${zfs.arcMax}`);
    if (zfs.copies) lines.push(`zfs.copies = ${zfs.copies}`);
    if (zfs.hdsize) lines.push(`zfs.hdsize = ${zfs.hdsize}`);
    lines.push('');
  }

  // LVM options
  if ((profile.diskSetup.filesystem === 'ext4' || profile.diskSetup.filesystem === 'xfs') && profile.diskSetup.lvm) {
    const lvm = profile.diskSetup.lvm;
    if (lvm.hdsize) lines.push(`lvm.hdsize = ${lvm.hdsize}`);
    if (lvm.swapsize !== undefined) lines.push(`lvm.swapsize = ${lvm.swapsize}`);
    if (lvm.maxroot) lines.push(`lvm.maxroot = ${lvm.maxroot}`);
    if (lvm.maxvz) lines.push(`lvm.maxvz = ${lvm.maxvz}`);
    if (lvm.minfree) lines.push(`lvm.minfree = ${lvm.minfree}`);
    lines.push('');
  }

  // Btrfs options
  if (profile.diskSetup.filesystem === 'btrfs' && profile.diskSetup.btrfs) {
    const btrfs = profile.diskSetup.btrfs;
    lines.push(`btrfs.raid = "${btrfs.raid}"`);
    if (btrfs.compress) lines.push(`btrfs.compress = "${btrfs.compress}"`);
    if (btrfs.hdsize) lines.push(`btrfs.hdsize = ${btrfs.hdsize}`);
    lines.push('');
  }

  // Post-installation webhook
  if (profile.postInstallWebhook) {
    lines.push('[post-installation-webhook]');
    lines.push(`url = "${profile.postInstallWebhook.url}"`);
    if (profile.postInstallWebhook.certFingerprint) {
      lines.push(`cert-fingerprint = "${profile.postInstallWebhook.certFingerprint}"`);
    }
    lines.push('');
  }

  // First-boot hook
  if (profile.firstBoot) {
    lines.push('[first-boot]');
    lines.push(`source = "${profile.firstBoot.source}"`);
    if (profile.firstBoot.ordering) {
      lines.push(`ordering = "${profile.firstBoot.ordering}"`);
    }
    if (profile.firstBoot.source === 'from-url' && profile.firstBoot.url) {
      lines.push(`url = "${profile.firstBoot.url}"`);
      if (profile.firstBoot.certFingerprint) {
        lines.push(`cert-fingerprint = "${profile.firstBoot.certFingerprint}"`);
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generates a build manifest for GitHub Actions
 */
export function generateBuildManifest(
  profiles: string[],
  isoSource: { type: 'url' | 'release'; url?: string; checksum?: string; releaseTag?: string },
  options: { publishRelease: boolean; releaseTag?: string }
): string {
  const manifest = {
    version: '1.0.0',
    profiles,
    isoSource,
    options,
    generatedAt: new Date().toISOString(),
  };
  return JSON.stringify(manifest, null, 2);
}

/**
 * Creates a GitHub Actions workflow dispatch URL
 */
export function generateWorkflowDispatchUrl(
  owner: string,
  repo: string,
  profiles: string[],
  isoUrl?: string
): string {
  const params = new URLSearchParams({
    profiles: profiles.join(','),
  });
  if (isoUrl) {
    params.set('iso_url', isoUrl);
  }
  return `https://github.com/${owner}/${repo}/actions/workflows/build-proxmox-iso.yml?${params.toString()}`;
}

/**
 * Creates a GitHub issue URL with pre-filled content for build request
 */
export function generateBuildRequestIssueUrl(
  owner: string,
  repo: string,
  profiles: NodeProfile[],
  isoSource: { type: 'url' | 'release'; url?: string; releaseTag?: string }
): string {
  const profileNames = profiles.map(p => `- \`${p.name}\` (${p.global.fqdn})`).join('\n');

  const body = `## Build Request

### Profiles to Build
${profileNames}

### ISO Source
- Type: \`${isoSource.type}\`
${isoSource.url ? `- URL: \`${isoSource.url}\`` : ''}
${isoSource.releaseTag ? `- Release: \`${isoSource.releaseTag}\`` : ''}

### Answer Files
<details>
<summary>Click to expand answer.toml files</summary>

${profiles.map(p => `#### ${p.name}
\`\`\`toml
${generateAnswerToml(p, true)}
\`\`\`
`).join('\n')}

</details>

---
*Generated by Proxmox Deployer UI*
`;

  const params = new URLSearchParams({
    title: `[Build Request] ${profiles.map(p => p.name).join(', ')}`,
    body,
    labels: 'build-request,automated',
  });

  return `https://github.com/${owner}/${repo}/issues/new?${params.toString()}`;
}

/**
 * Download content as a file
 */
export function downloadFile(content: string, filename: string, mimeType = 'text/plain'): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
